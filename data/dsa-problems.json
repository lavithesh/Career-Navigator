[
  {
    "problemId": 1,
    "courseId": "javascript",
    "title": "Sum Array Elements",
    "difficulty": "Easy",
    "description": "Write a function that takes an array of numbers and returns the sum of all elements.",
    "examples": [
      {
        "input": "[1, 2, 3, 4, 5]\n",
        "output": "15\n",
        "explanation": "1 + 2 + 3 + 4 + 5 = 15\n"
      },
      {
        "input": "[-1, -2, 3, 4]\n",
        "output": "4\n",
        "explanation": "-1 + (-2) + 3 + 4 = 4\n"
      }
    ],
    "constraints": [
      "Array length will be between 0 and 10^5",
      "Array elements will be between -10^4 and 10^4"
    ],
    "testCases": [
      {
        "input": "[1, 2, 3, 4, 5]",
        "expectedOutput": "15"
      },
      {
        "input": "[-1, -2, 3, 4]",
        "expectedOutput": "4"
      },
      {
        "input": "[]",
        "expectedOutput": "0",
        "isHidden": true
      }
    ],
    "hints": [
      "Consider using a loop to iterate through the array",
      "You can also use the Array.reduce() method for a more concise solution"
    ]
  },
  
  {
    "problemId": 2,
    "courseId": "javascript",
    "title": "Merge k Sorted Lists",
    "difficulty": "Hard",
    "description": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\n\nMerge all the linked-lists into one sorted linked-list and return it.\n",
    "examples": [
      {
        "input": "lists = [[1,4,5],[1,3,4],[2,6]]\n",
        "output": "[1,1,2,3,4,4,5,6]\n",
        "explanation": "The linked-lists are:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nmerging them into one sorted list:\n1->1->2->3->4->4->5->6\n"
      },
      {
        "input": "lists = []\n",
        "output": "[]\n",
        "explanation": "The input array is empty, so the result is also empty.\n"
      },
      {
        "input": "lists = [[]]\n",
        "output": "[]\n",
        "explanation": "The input array contains one empty list, so the result is empty.\n"
      }
    ],
    "constraints": [
      "k == lists.length\n",
      "0 <= k <= 10^4\n",
      "0 <= lists[i].length <= 500\n",
      "-10^4 <= lists[i][j] <= 10^4\n",
      "lists[i] is sorted in ascending order.\n",
      "The sum of lists[i].length will not exceed 10^4.\n"
    ],
    "testCases": [
      {
        "input": "lists = [[1,4,5],[1,3,4],[2,6]]\n",
        "expectedOutput": "[1,1,2,3,4,4,5,6]\n"
      },
      {
        "input": "lists = []\n",
        "expectedOutput": "[]\n"
      },
      {
        "input": "lists = [[]]\n",
        "expectedOutput": "[]\n"
      },
      {
        "input": "lists = [[1,2,3],[4,5,6],[7,8,9]]\n",
        "expectedOutput": "[1,2,3,4,5,6,7,8,9]\n",
        "isHidden": true
      },
      {
        "input": "lists = [[1,4],[2,5],[],[3,6]]\n",
        "expectedOutput": "[1,2,3,4,5,6]\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Think about how you would merge two sorted lists and extend that approach.\n",
      "A priority queue (min-heap) can help efficiently get the next smallest node.\n",
      "Consider a divide and conquer approach that reduces the problem to multiple merges of two lists.\n"
    ]
  },
  {
    "problemId": 3,
    "courseId": "javascript",
    "title": "Two Sum",
    "difficulty": "Easy",
    "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.",
    "examples": [
      {
        "input": "nums = [2,7,11,15]\n target = 9\n",
        "output": "[0,1]\n",
        "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1].\n"
      },
      {
        "input": "nums = [3,2,4]\n target = 6\n",
        "output": "[1,2]\n",
        "explanation": "Because nums[1] + nums[2] == 6, we return [1, 2].\n"
      },
      {
        "input": "nums = [3,3]\n target = 6\n",
        "output": "[0,1]\n",
        "explanation": "Because nums[0] + nums[1] == 6, we return [0, 1].\n"
      }
    ],
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9",
      "Only one valid answer exists."
    ],
    "testCases": [
      {
        "input": "nums = [2,7,11,15]\n target = 9\n",
        "expectedOutput": "[0,1]\n"
      },
      {
        "input": "nums = [3,2,4]\n target = 6\n",
        "expectedOutput": "[1,2]\n"
      },
      {
        "input": "nums = [3,3]\n target = 6\n",
        "expectedOutput": "[0,1]\n",
        "isHidden": true
      }
    ],
    "hints": [
      "A brute force approach would be to check all pairs, but it's inefficient.",
      "Consider using a hash map to store elements for faster lookup.",
      "If we fix one number x, we need to find target - x quickly. Can we use additional space to speed up the search?"
    ]
  },
  {
    "problemId": 4,
    "courseId": "javascript",
    "title": "Longest Substring Without Repeating Characters",
    "difficulty": "Medium",
    "description": "Given a string s, find the length of the longest substring without duplicate characters.",
    "examples": [
      {
        "input": "s = \"abcabcbb\"\n",
        "output": "3\n",
        "explanation": "The answer is \"abc\", with the length of 3.\n"
      },
      {
        "input": "s = \"bbbbb\"\n",
        "output": "1\n",
        "explanation": "The answer is \"b\", with the length of 1.\n"
      },
      {
        "input": "s = \"pwwkew\"\n",
        "output": "3\n",
        "explanation": "The answer is \"wke\", with the length of 3. Note that \"pwke\" is a subsequence, not a substring.\n"
      }
    ],
    "constraints": [
      "0 <= s.length <= 5 * 10^4",
      "s consists of English letters, digits, symbols, and spaces."
    ],
    "testCases": [
      {
        "input": "s = \"abcabcbb\"\n",
        "expectedOutput": "3\n"
      },
      {
        "input": "s = \"bbbbb\"\n",
        "expectedOutput": "1\n"
      },
      {
        "input": "s = \"pwwkew\"\n",
        "expectedOutput": "3\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Generate all possible substrings and check for duplicates, keeping track of the maximum length.",
      "Consider using a sliding window approach to optimize the solution."
    ]
  },
  {
    "problemId": 5,
    "courseId": "javascript",
    "title": "Longest Palindromic Substring",
    "difficulty": "Medium",
    "description": "Given a string s, return the longest palindromic substring in s.",
    "examples": [
      {
        "input": "s = \"babad\"\n",
        "output": "\"bab\"\n",
        "explanation": "\"aba\" is also a valid answer.\n"
      },
      {
        "input": "s = \"cbbd\"\n",
        "output": "\"bb\"\n",
        "explanation": "The longest palindromic substring is \"bb\".\n"
      }
    ],
    "constraints": [
      "1 <= s.length <= 1000",
      "s consists of only digits and English letters."
    ],
    "testCases": [
      {
        "input": "s = \"babad\"\n",
        "expectedOutput": "\"bab\"\n"
      },
      {
        "input": "s = \"cbbd\"\n",
        "expectedOutput": "\"bb\"\n"
      }
    ],
    "hints": [
      "How can we reuse a previously computed palindrome to compute a larger palindrome?",
      "If \"aba\" is a palindrome, is \"xabax\" a palindrome? Similarly, is \"xabay\" a palindrome?",
      "A brute-force approach checks every substring for palindrome properties (O(n³)). Can we reduce palindrome check time to O(1) using previous computations?"
    ]
  },
  {
    "problemId": 6,
    "courseId": "javascript",
    "title": "Container With Most Water",
    "difficulty": "Medium",
    "description": "Given an integer array height of length n, find two lines that together with the x-axis form a container, such that the container contains the most water. Return the maximum amount of water a container can store.",
    "examples": [
      {
        "input": "height = [1,8,6,2,5,4,8,3,7]\n",
        "output": "49\n",
        "explanation": "The max area of water the container can hold is 49.\n"
      },
      {
        "input": "height = [1,1]\n",
        "output": "1\n",
        "explanation": "The maximum area the container can hold is 1.\n"
      }
    ],
    "constraints": [
      "n == height.length",
      "2 <= n <= 10^5",
      "0 <= height[i] <= 10^4"
    ],
    "testCases": [
      {
        "input": "height = [1,8,6,2,5,4,8,3,7]\n",
        "expectedOutput": "49\n"
      },
      {
        "input": "height = [1,1]\n",
        "expectedOutput": "1\n"
      }
    ],
    "hints": [
      "If you simulate the problem using brute force, it will be O(n^2), which is not efficient.",
      "Try using two pointers: one at the leftmost position and one at the rightmost position. Move the pointer that points to the lower line.",
      "The amount of water at each step is calculated as the width times the minimum of the two heights."
    ]
  },
  {
    "problemId": 7,
    "courseId": "javascript",
    "title": "3Sum",
    "difficulty": "Medium",
    "description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. The solution set must not contain duplicate triplets.",
    "examples": [
      {
        "input": "nums = [-1,0,1,2,-1,-4]\n",
        "output": "[[-1,-1,2],[-1,0,1]]\n",
        "explanation": "The distinct triplets that sum to 0 are [-1,-1,2] and [-1,0,1].\n"
      },
      {
        "input": "nums = [0,1,1]\n",
        "output": "[]\n",
        "explanation": "There are no triplets that sum up to 0.\n"
      },
      {
        "input": "nums = [0,0,0]\n",
        "output": "[[0,0,0]]\n",
        "explanation": "The only possible triplet that sums to 0 is [0,0,0].\n"
      }
    ],
    "constraints": [
      "3 <= nums.length <= 3000",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "testCases": [
      {
        "input": "nums = [-1,0,1,2,-1,-4]\n",
        "expectedOutput": "[[-1,-1,2],[-1,0,1]]\n"
      },
      {
        "input": "nums = [0,1,1]\n",
        "expectedOutput": "[]\n"
      },
      {
        "input": "nums = [0,0,0]\n",
        "expectedOutput": "[[0,0,0]]\n"
      }
    ],
    "hints": [
      "To find three numbers x, y, and z that sum to zero, fix one number x and solve the Two Sum problem for y and z.",
      "Sort the array first and use a two-pointer approach to efficiently find pairs that sum to the target.",
      "Use a hash set to avoid duplicate triplets."
    ]
  },
  {
    "problemId": 8,
    "courseId": "javascript",
    "title": "Combination Sum",
    "difficulty": "Medium",
    "description": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\n\nThe same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\n\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\n",
    "examples": [
      {
        "input": "candidates = [2,3,6,7], target = 7\n",
        "output": "[[2,2,3],[7]]\n",
        "explanation": "2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.\n"
      },
      {
        "input": "candidates = [2,3,5], target = 8\n",
        "output": "[[2,2,2,2],[2,3,3],[3,5]]\n",
        "explanation": "Multiple combinations sum to the target value 8.\n"
      },
      {
        "input": "candidates = [2], target = 1\n",
        "output": "[]\n",
        "explanation": "No combinations sum to the target value 1.\n"
      }
    ],
    "constraints": [
      "1 <= candidates.length <= 30\n",
      "2 <= candidates[i] <= 40\n",
      "All elements of candidates are distinct.\n",
      "1 <= target <= 40\n"
    ],
    "testCases": [
      {
        "input": "candidates = [2,3,6,7], target = 7\n",
        "expectedOutput": "[[2,2,3],[7]]\n"
      },
      {
        "input": "candidates = [2,3,5], target = 8\n",
        "expectedOutput": "[[2,2,2,2],[2,3,3],[3,5]]\n"
      },
      {
        "input": "candidates = [2], target = 1\n",
        "expectedOutput": "[]\n"
      },
      {
        "input": "candidates = [3,5,8], target = 11\n",
        "expectedOutput": "[[3,3,5],[3,8]]\n",
        "isHidden": true
      },
      {
        "input": "candidates = [2,4,6], target = 6\n",
        "expectedOutput": "[[2,2,2],[2,4],[6]]\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Consider using a backtracking approach to explore all possible combinations.\n",
      "Think about how to avoid duplicate combinations in your solution.\n",
      "Sorting the array first might help in optimizing the backtracking process.\n",
      "Remember that you can use the same number multiple times in combinations.\n"
    ],
    "tags": ["array", "backtracking"]
  },
  {
    "problemId": 9,
    "courseId": "javascript",
    "title": "Rotate Image",
    "difficulty": "Medium",
    "description": "You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\n\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n",
    "examples": [
      {
        "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]\n",
        "output": "[[7,4,1],[8,5,2],[9,6,3]]\n",
        "explanation": "The matrix was rotated 90 degrees clockwise:\n\n1 2 3       7 4 1\n4 5 6  →  8 5 2\n7 8 9       9 6 3\n"
      },
      {
        "input": "matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n",
        "output": "[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n",
        "explanation": "The 4x4 matrix was rotated 90 degrees clockwise.\n"
      }
    ],
    "constraints": [
      "n == matrix.length == matrix[i].length\n",
      "1 <= n <= 20\n",
      "-1000 <= matrix[i][j] <= 1000\n"
    ],
    "testCases": [
      {
        "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]\n",
        "expectedOutput": "[[7,4,1],[8,5,2],[9,6,3]]\n"
      },
      {
        "input": "matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n",
        "expectedOutput": "[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n"
      },
      {
        "input": "matrix = [[1]]\n",
        "expectedOutput": "[[1]]\n",
        "isHidden": true
      },
      {
        "input": "matrix = [[1,2],[3,4]]\n",
        "expectedOutput": "[[3,1],[4,2]]\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Think about how the rotation affects the matrix elements' positions.\n",
      "Consider performing the rotation in layers, from the outer layer to the inner layers.\n",
      "You can perform the rotation in two steps: transpose the matrix, then reverse each row.\n",
      "For in-place rotation, you'll need to swap elements in a specific pattern.\n"
    ],
    "tags": ["array", "math", "matrix"]
  },
  {
    "problemId": 10,
    "courseId": "javascript",
    "title": "Group Anagrams",
    "difficulty": "Medium",
    "description": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.\n\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n",
    "examples": [
      {
        "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\n",
        "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n",
        "explanation": "There is no string in strs that can be rearranged to form \"bat\".\nThe strings \"nat\" and \"tan\" are anagrams as they can be rearranged to form each other.\nThe strings \"ate\", \"eat\", and \"tea\" are anagrams as they can be rearranged to form each other.\n"
      },
      {
        "input": "strs = [\"\"]\n",
        "output": "[[\"\"]]\n",
        "explanation": "The input contains one empty string which forms its own group.\n"
      },
      {
        "input": "strs = [\"a\"]\n",
        "output": "[[\"a\"]]\n",
        "explanation": "The input contains one single-character string which forms its own group.\n"
      }
    ],
    "constraints": [
      "1 <= strs.length <= 10^4\n",
      "0 <= strs[i].length <= 100\n",
      "strs[i] consists of lowercase English letters.\n"
    ],
    "testCases": [
      {
        "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\n",
        "expectedOutput": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n"
      },
      {
        "input": "strs = [\"\"]\n",
        "expectedOutput": "[[\"\"]]\n"
      },
      {
        "input": "strs = [\"a\"]\n",
        "expectedOutput": "[[\"a\"]]\n"
      },
      {
        "input": "strs = [\"listen\",\"silent\",\"enlist\",\"hello\",\"world\",\"dlrow\"]\n",
        "expectedOutput": "[[\"hello\"],[\"world\",\"dlrow\"],[\"listen\",\"silent\",\"enlist\"]]\n",
        "isHidden": true
      },
      {
        "input": "strs = [\"\", \"\"]\n",
        "expectedOutput": "[[\"\", \"\"]]\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Anagrams will have the same sorted string representation.\n",
      "Use a hash map to group strings by their sorted representation.\n",
      "Consider the empty string as a special case.\n",
      "Think about how to efficiently group strings without sorting each one individually.\n"
    ],
    "tags": ["array", "hash-table", "string", "sorting"]
  },
  {
    "problemId": 11,
    "courseId": "javascript",
    "title": "Maximum Subarray",
    "difficulty": "Medium",
    "description": "Given an integer array nums, find the subarray with the largest sum, and return its sum.\n",
    "examples": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]\n",
        "output": "6\n",
        "explanation": "The subarray [4,-1,2,1] has the largest sum 6.\n"
      },
      {
        "input": "nums = [1]\n",
        "output": "1\n",
        "explanation": "The subarray [1] has the largest sum 1.\n"
      },
      {
        "input": "nums = [5,4,-1,7,8]\n",
        "output": "23\n",
        "explanation": "The subarray [5,4,-1,7,8] has the largest sum 23.\n"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^5\n",
      "-10^4 <= nums[i] <= 10^4\n"
    ],
    "testCases": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]\n",
        "expectedOutput": "6\n"
      },
      {
        "input": "nums = [1]\n",
        "expectedOutput": "1\n"
      },
      {
        "input": "nums = [5,4,-1,7,8]\n",
        "expectedOutput": "23\n"
      },
      {
        "input": "nums = [-1,-2,-3,-4]\n",
        "expectedOutput": "-1\n",
        "isHidden": true
      },
      {
        "input": "nums = [2,-1,2,3,4,-5,4,5,-2]\n",
        "expectedOutput": "10\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Think about the optimal substructure property for this problem.\n",
      "Consider Kadane's algorithm for an O(n) solution.\n",
      "For the divide and conquer approach, the maximum subarray can be either in the left half, right half, or crossing the midpoint.\n",
      "How would you handle arrays with all negative numbers?\n"
    ],
    "tags": ["array", "divide-and-conquer", "dynamic-programming"]
  },
  {
    "problemId": 12,
    "courseId": "javascript",
    "title": "Spiral Matrix",
    "difficulty": "Medium",
    "description": "Given an m x n matrix, return all elements of the matrix in spiral order.\n\nSpiral order means traversing the matrix in a clockwise spiral starting from the top-left corner.\n",
    "examples": [
      {
        "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]\n",
        "output": "[1,2,3,6,9,8,7,4,5]\n",
        "explanation": "The spiral order traversal is:\n1→2→3→6→9→8→7→4→5\n"
      },
      {
        "input": "matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n",
        "output": "[1,2,3,4,8,12,11,10,9,5,6,7]\n",
        "explanation": "The spiral order traversal is:\n1→2→3→4→8→12→11→10→9→5→6→7\n"
      }
    ],
    "constraints": [
      "m == matrix.length\n",
      "n == matrix[i].length\n",
      "1 <= m, n <= 10\n",
      "-100 <= matrix[i][j] <= 100\n"
    ],
    "testCases": [
      {
        "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]\n",
        "expectedOutput": "[1,2,3,6,9,8,7,4,5]\n"
      },
      {
        "input": "matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n",
        "expectedOutput": "[1,2,3,4,8,12,11,10,9,5,6,7]\n"
      },
      {
        "input": "matrix = [[1]]\n",
        "expectedOutput": "[1]\n",
        "isHidden": true
      },
      {
        "input": "matrix = [[1,2],[3,4],[5,6]]\n",
        "expectedOutput": "[1,2,4,6,5,3]\n",
        "isHidden": true
      },
      {
        "input": "matrix = [[1,2,3,4,5]]\n",
        "expectedOutput": "[1,2,3,4,5]\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Think about traversing the matrix layer by layer in a spiral pattern.\n",
      "Define boundaries for top, bottom, left, and right edges of the current spiral layer.\n",
      "After traversing each edge, adjust the corresponding boundary inward.\n",
      "Special cases to consider: single row, single column, and rectangular matrices.\n",
      "The process continues until all layers are traversed (top <= bottom and left <= right).\n"
    ],
    "tags": ["array", "matrix", "simulation"]
  },
  {
    "problemId": 13,
    "courseId": "javascript",
    "title": "Jump Game",
    "difficulty": "Medium",
    "description": "You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\n\nReturn true if you can reach the last index, or false otherwise.\n",
    "examples": [
      {
        "input": "nums = [2,3,1,1,4]\n",
        "output": "true\n",
        "explanation": "Jump 1 step from index 0 to 1, then 3 steps to the last index.\n"
      },
      {
        "input": "nums = [3,2,1,0,4]\n",
        "output": "false\n",
        "explanation": "You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^4\n",
      "0 <= nums[i] <= 10^5\n"
    ],
    "testCases": [
      {
        "input": "nums = [2,3,1,1,4]\n",
        "expectedOutput": "true\n"
      },
      {
        "input": "nums = [3,2,1,0,4]\n",
        "expectedOutput": "false\n"
      },
      {
        "input": "nums = [0]\n",
        "expectedOutput": "true\n",
        "isHidden": true
      },
      {
        "input": "nums = [1,0,1,0]\n",
        "expectedOutput": "false\n",
        "isHidden": true
      },
      {
        "input": "nums = [2,0,0,1,4]\n",
        "expectedOutput": "false\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Think about how far you can jump from each position.\n",
      "Track the farthest index you can reach at each step.\n",
      "If at any point your current index exceeds the farthest reachable index, return false.\n",
      "If you can reach or surpass the last index, return true.\n",
      "Consider the greedy approach for an optimal solution.\n"
    ],
    "tags": ["array", "dynamic-programming", "greedy"]
  },
  {
    "problemId": 14,
    "courseId": "javascript",
    "title": "Merge Intervals",
    "difficulty": "Medium",
    "description": "Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n",
    "examples": [
      {
        "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]\n",
        "output": "[[1,6],[8,10],[15,18]]\n",
        "explanation": "Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\nThe other intervals remain unchanged as they don't overlap.\n"
      },
      {
        "input": "intervals = [[1,4],[4,5]]\n",
        "output": "[[1,5]]\n",
        "explanation": "Intervals [1,4] and [4,5] are considered overlapping and merge into [1,5].\n"
      }
    ],
    "constraints": [
      "1 <= intervals.length <= 10^4\n",
      "intervals[i].length == 2\n",
      "0 <= starti <= endi <= 10^4\n"
    ],
    "testCases": [
      {
        "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]\n",
        "expectedOutput": "[[1,6],[8,10],[15,18]]\n"
      },
      {
        "input": "intervals = [[1,4],[4,5]]\n",
        "expectedOutput": "[[1,5]]\n"
      },
      {
        "input": "intervals = [[1,4],[0,4]]\n",
        "expectedOutput": "[[0,4]]\n",
        "isHidden": true
      },
      {
        "input": "intervals = [[1,4],[2,3]]\n",
        "expectedOutput": "[[1,4]]\n",
        "isHidden": true
      },
      {
        "input": "intervals = [[1,4],[5,6]]\n",
        "expectedOutput": "[[1,4],[5,6]]\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Sort the intervals based on their start times.\n",
      "Initialize a merged list with the first interval.\n",
      "Iterate through the sorted intervals and merge them if they overlap with the last merged interval.\n",
      "Two intervals overlap if the start of one is less than or equal to the end of the other.\n",
      "When merging, update the end of the last merged interval to be the maximum of both ends.\n"
    ],
    "tags": ["array", "sorting"]
  },
  {
    "problemId": 15,
    "courseId": "javascript",
    "title": "Insert Interval",
    "difficulty": "Medium",
    "description": "You are given an array of non-overlapping intervals sorted by start time and a new interval to insert. Insert the new interval into the array while maintaining the sorted order and merging any overlapping intervals if necessary.\n",
    "examples": [
      {
        "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]\n",
        "output": "[[1,5],[6,9]]\n",
        "explanation": "The new interval [2,5] overlaps with [1,3], so they are merged into [1,5].\n"
      },
      {
        "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\n",
        "output": "[[1,2],[3,10],[12,16]]\n",
        "explanation": "The new interval [4,8] overlaps with [3,5], [6,7], and [8,10], resulting in [3,10].\n"
      }
    ],
    "constraints": [
      "0 <= intervals.length <= 10^4\n",
      "intervals[i].length == 2\n",
      "0 <= starti <= endi <= 10^5\n",
      "intervals is sorted by starti in ascending order\n",
      "newInterval.length == 2\n",
      "0 <= start <= end <= 10^5\n"
    ],
    "testCases": [
      {
        "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]\n",
        "expectedOutput": "[[1,5],[6,9]]\n"
      },
      {
        "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\n",
        "expectedOutput": "[[1,2],[3,10],[12,16]]\n"
      },
      {
        "input": "intervals = [], newInterval = [5,7]\n",
        "expectedOutput": "[[5,7]]\n",
        "isHidden": true
      },
      {
        "input": "intervals = [[1,5]], newInterval = [2,3]\n",
        "expectedOutput": "[[1,5]]\n",
        "isHidden": true
      },
      {
        "input": "intervals = [[1,5],[10,15],[20,25]], newInterval = [6,8]\n",
        "expectedOutput": "[[1,5],[6,8],[10,15],[20,25]]\n",
        "isHidden": true
      }
    ],
    "hints": [
      "The intervals are already sorted - take advantage of this.\n",
      "First, add all intervals that come before the new interval.\n",
      "Then merge the new interval with any overlapping intervals.\n",
      "Finally, add all remaining intervals that come after the merged interval.\n",
      "Consider edge cases where the new interval is at the beginning or end of the array.\n"
    ],
    "tags": ["array"]
  },
  {
    "problemId": 16,
    "courseId": "javascript",
    "title": "Unique Paths",
    "difficulty": "Medium",
    "description": "There is a robot on an m x n grid. The robot is initially located at the top-left corner (grid[0][0]). The robot tries to move to the bottom-right corner (grid[m-1][n-1]). The robot can only move either down or right at any point in time.\n\nGiven two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.\n",
    "examples": [
      {
        "input": "m = 3, n = 7\n",
        "output": "28\n",
        "explanation": "There are 28 possible unique paths from top-left to bottom-right in a 3x7 grid.\n"
      },
      {
        "input": "m = 3, n = 2\n",
        "output": "3\n",
        "explanation": "From the top-left corner, there are 3 ways to reach the bottom-right corner:\n1. Right → Down → Down\n2. Down → Down → Right\n3. Down → Right → Down\n"
      }
    ],
    "constraints": [
      "1 <= m, n <= 100\n",
      "The answer will be less than or equal to 2 * 10^9\n"
    ],
    "testCases": [
      {
        "input": "m = 3, n = 7\n",
        "expectedOutput": "28\n"
      },
      {
        "input": "m = 3, n = 2\n",
        "expectedOutput": "3\n"
      },
      {
        "input": "m = 1, n = 1\n",
        "expectedOutput": "1\n",
        "isHidden": true
      },
      {
        "input": "m = 7, n = 3\n",
        "expectedOutput": "28\n",
        "isHidden": true
      },
      {
        "input": "m = 10, n = 10\n",
        "expectedOutput": "48620\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Think about how many ways you can reach each cell in the grid.\n",
      "The number of ways to reach a cell is the sum of ways to reach the cell above it and the cell to its left.\n",
      "You can solve this using dynamic programming by building a 2D array to store paths counts.\n",
      "There's also a mathematical solution using combinations (m+n-2 choose m-1).\n",
      "Consider that the grid is small enough that integer overflow won't be a problem.\n"
    ],
    "tags": ["math", "dynamic-programming", "combinatorics"]
  },
  {
    "problemId": 17,
    "courseId": "javascript",
    "title": "Climbing Stairs",
    "difficulty": "Easy",
    "description": "You are climbing a staircase. It takes n steps to reach the top.\n\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n",
    "examples": [
      {
        "input": "n = 2\n",
        "output": "2\n",
        "explanation": "There are two ways to climb to the top:\n1. 1 step + 1 step\n2. 2 steps\n"
      },
      {
        "input": "n = 3\n",
        "output": "3\n",
        "explanation": "There are three ways to climb to the top:\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n"
      }
    ],
    "constraints": [
      "1 <= n <= 45\n"
    ],
    "testCases": [
      {
        "input": "n = 2\n",
        "expectedOutput": "2\n"
      },
      {
        "input": "n = 3\n",
        "expectedOutput": "3\n"
      },
      {
        "input": "n = 1\n",
        "expectedOutput": "1\n",
        "isHidden": true
      },
      {
        "input": "n = 4\n",
        "expectedOutput": "5\n",
        "isHidden": true
      },
      {
        "input": "n = 5\n",
        "expectedOutput": "8\n",
        "isHidden": true
      }
    ],
    "hints": [
      "This problem follows the Fibonacci sequence pattern.\n",
      "The number of ways to reach step n is the sum of ways to reach step n-1 and step n-2.\n",
      "You can solve this using dynamic programming with O(n) time and O(1) space.\n",
      "Consider base cases: 1 way for n=1, 2 ways for n=2.\n",
      "The sequence will be: 1, 2, 3, 5, 8, 13... for n=1,2,3,4,5,6...\n"
    ],
    "tags": ["math", "dynamic-programming", "memoization"]
  },
  {
    "problemId": 18,
    "courseId": "javascript",
    "title": "Set Matrix Zeroes",
    "difficulty": "Medium",
    "description": "Given an m x n integer matrix, if an element is 0, set its entire row and column to 0's. You must do this in place.\n",
    "examples": [
      {
        "input": "matrix = [[1,1,1],[1,0,1],[1,1,1]]\n",
        "output": "[[1,0,1],[0,0,0],[1,0,1]]\n",
        "explanation": "The center element is 0, so its entire row and column are set to 0.\n"
      },
      {
        "input": "matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\n",
        "output": "[[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n",
        "explanation": "The first and last elements of first row are 0, so their entire rows and columns are set to 0.\n"
      }
    ],
    "constraints": [
      "m == matrix.length\n",
      "n == matrix[0].length\n",
      "1 <= m, n <= 200\n",
      "-2^31 <= matrix[i][j] <= 2^31 - 1\n"
    ],
    "testCases": [
      {
        "input": "matrix = [[1,1,1],[1,0,1],[1,1,1]]\n",
        "expectedOutput": "[[1,0,1],[0,0,0],[1,0,1]]\n"
      },
      {
        "input": "matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\n",
        "expectedOutput": "[[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n"
      },
      {
        "input": "matrix = [[1]]\n",
        "expectedOutput": "[[1]]\n",
        "isHidden": true
      },
      {
        "input": "matrix = [[1,0],[1,1]]\n",
        "expectedOutput": "[[0,0],[1,0]]\n",
        "isHidden": true
      },
      {
        "input": "matrix = [[1,2,3,4],[5,0,7,8],[0,10,11,12],[13,14,15,0]]\n",
        "expectedOutput": "[[0,0,3,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]]\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Use the first cell of each row and column as flags to mark if that row/column should be set to zero.\n",
      "First, check if the first row and column need to be zeroed out.\n",
      "Then use the rest of the matrix to mark which rows and columns should be zeroed.\n",
      "Finally, use the flags to set zeros in the appropriate cells.\n",
      "Remember to handle the first row and column separately at the end.\n"
    ],
    "tags": ["array", "hash-table", "matrix"]
  },
  {
    "problemId": 19,
    "courseId": "javascript",
    "title": "Minimum Window Substring",
    "difficulty": "Hard",
    "description": "Given two strings s and t, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".\n\nThe testcases will be generated such that the answer is unique.\n",
    "examples": [
      {
        "input": "s = \"ADOBECODEBANC\", t = \"ABC\"\n",
        "output": "\"BANC\"\n",
        "explanation": "The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\n"
      },
      {
        "input": "s = \"a\", t = \"a\"\n",
        "output": "\"a\"\n",
        "explanation": "The entire string s is the minimum window.\n"
      },
      {
        "input": "s = \"a\", t = \"aa\"\n",
        "output": "\"\"\n",
        "explanation": "Both 'a's from t must be included in the window.\nSince the largest window of s only has one 'a', return empty string.\n"
      }
    ],
    "constraints": [
      "m == s.length\n",
      "n == t.length\n",
      "1 <= m, n <= 10^5\n",
      "s and t consist of uppercase and lowercase English letters.\n"
    ],
    "testCases": [
      {
        "input": "s = \"ADOBECODEBANC\", t = \"ABC\"\n",
        "expectedOutput": "\"BANC\"\n"
      },
      {
        "input": "s = \"a\", t = \"a\"\n",
        "expectedOutput": "\"a\"\n"
      },
      {
        "input": "s = \"a\", t = \"aa\"\n",
        "expectedOutput": "\"\"\n"
      },
      {
        "input": "s = \"ab\", t = \"b\"\n",
        "expectedOutput": "\"b\"\n",
        "isHidden": true
      },
      {
        "input": "s = \"cabwefgewcwaefgcf\", t = \"cae\"\n",
        "expectedOutput": "\"cwae\"\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Use two pointers to create a sliding window that tracks the current substring being examined.\n",
      "First, expand the window by moving the right pointer until all characters from t are included.\n",
      "Then, contract the window from the left to find the smallest valid substring.\n",
      "Keep track of character counts using a hash map to efficiently check when the window contains all required characters.\n",
      "Optimize by maintaining counters for the number of characters still needed to satisfy t's requirements.\n"
    ],
    "tags": ["hash-table", "string", "sliding-window"]
  },
  {
    "problemId": 20,
    "courseId": "javascript",
    "title": "Word Search",
    "difficulty": "Medium",
    "description": "Given an m x n grid of characters board and a string word, return true if word exists in the grid.\n\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\n",
    "examples": [
      {
        "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\n",
        "output": "true\n",
        "explanation": "The word can be constructed as: A→B→C→C→E→D\n"
      },
      {
        "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"\n",
        "output": "true\n",
        "explanation": "The word can be constructed as: S→E→E\n"
      },
      {
        "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"\n",
        "output": "false\n",
        "explanation": "The letter B cannot be used twice in the path.\n"
      }
    ],
    "constraints": [
      "m == board.length\n",
      "n == board[i].length\n",
      "1 <= m, n <= 6\n",
      "1 <= word.length <= 15\n",
      "board and word consist of only lowercase and uppercase English letters.\n"
    ],
    "testCases": [
      {
        "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\n",
        "expectedOutput": "true\n"
      },
      {
        "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"\n",
        "expectedOutput": "true\n"
      },
      {
        "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"\n",
        "expectedOutput": "false\n"
      },
      {
        "input": "board = [[\"a\"]], word = \"a\"\n",
        "expectedOutput": "true\n",
        "isHidden": true
      },
      {
        "input": "board = [[\"A\",\"B\"],[\"C\",\"D\"]], word = \"ABCD\"\n",
        "expectedOutput": "false\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Use backtracking/DFS to explore all possible paths in the grid.\n",
      "Mark visited cells to prevent reuse during the current path exploration.\n",
      "Prune the search early when the current path cannot possibly form the word.\n",
      "Consider converting the word to a character array for faster access.\n",
      "Optimize by checking if the board contains all characters from the word before starting the search.\n"
    ],
    "tags": ["array", "string", "backtracking", "depth-first-search", "matrix"]
  },
  {
    "problemId": 21,
    "courseId": "javascript",
    "title": "Decode Ways",
    "difficulty": "Medium",
    "description": "A message containing letters from A-Z can be encoded into numbers using the following mapping:\n\n'A' -> \"1\"\n'B' -> \"2\"\n...\n'Z' -> \"26\"\n\nGiven a string s containing only digits, return the number of ways to decode it. Return 0 if the string cannot be decoded.\n",
    "examples": [
      {
        "input": "s = \"12\"\n",
        "output": "2\n",
        "explanation": "\"12\" could be decoded as \"AB\" (1 2) or \"L\" (12).\n"
      },
      {
        "input": "s = \"226\"\n",
        "output": "3\n",
        "explanation": "\"226\" could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6).\n"
      },
      {
        "input": "s = \"06\"\n",
        "output": "0\n",
        "explanation": "\"06\" cannot be mapped to \"F\" because of the leading zero (\"6\" is valid but \"06\" is not).\n"
      }
    ],
    "constraints": [
      "1 <= s.length <= 100\n",
      "s contains only digits and may contain leading zero(s).\n",
      "The answer is guaranteed to fit in a 32-bit integer.\n"
    ],
    "testCases": [
      {
        "input": "s = \"12\"\n",
        "expectedOutput": "2\n"
      },
      {
        "input": "s = \"226\"\n",
        "expectedOutput": "3\n"
      },
      {
        "input": "s = \"06\"\n",
        "expectedOutput": "0\n"
      },
      {
        "input": "s = \"10\"\n",
        "expectedOutput": "1\n",
        "isHidden": true
      },
      {
        "input": "s = \"2101\"\n",
        "expectedOutput": "1\n",
        "isHidden": true
      },
      {
        "input": "s = \"111111111111111111111111111111111111111111111\"\n",
        "expectedOutput": "1836311903\n",
        "isHidden": true
      }
    ],
    "hints": [
      "This problem can be solved using dynamic programming.\n",
      "Create a DP array where dp[i] represents the number of ways to decode the first i characters.\n",
      "For each position, consider both single-digit and two-digit decoding possibilities.\n",
      "Handle edge cases carefully: numbers starting with 0, and numbers greater than 26.\n",
      "The recurrence relation is similar to the Fibonacci sequence but with additional constraints.\n"
    ],
    "tags": ["string", "dynamic-programming"]
  },
  {
    "problemId": 22,
    "courseId": "javascript",
    "title": "Validate Binary Search Tree",
    "difficulty": "Medium",
    "description": "Given the root of a binary tree, determine if it is a valid binary search tree (BST).\n\nA valid BST is defined as follows:\n- The left subtree of a node contains only nodes with keys less than the node's key.\n- The right subtree of a node contains only nodes with keys greater than the node's key.\n- Both the left and right subtrees must also be binary search trees.\n",
    "examples": [
      {
        "input": "root = [2,1,3]\n",
        "output": "true\n",
        "explanation": "The tree satisfies all BST properties:\n  2\n / \\\n1   3\n"
      },
      {
        "input": "root = [5,1,4,null,null,3,6]\n",
        "output": "false\n",
        "explanation": "The root node's value is 5 but its right child's value is 4 (which should be greater than 5).\n    5\n   / \\\n  1   4\n     / \\\n    3   6\n"
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range [1, 10^4].\n",
      "-2^31 <= Node.val <= 2^31 - 1\n"
    ],
    "testCases": [
      {
        "input": "root = [2,1,3]\n",
        "expectedOutput": "true\n"
      },
      {
        "input": "root = [5,1,4,null,null,3,6]\n",
        "expectedOutput": "false\n"
      },
      {
        "input": "root = [1]\n",
        "expectedOutput": "true\n",
        "isHidden": true
      },
      {
        "input": "root = [5,4,6,null,null,3,7]\n",
        "expectedOutput": "false\n",
        "isHidden": true
      },
      {
        "input": "root = [2147483647]\n",
        "expectedOutput": "true\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Use depth-first search to traverse the tree.\n",
      "For each node, keep track of the minimum and maximum values it can have based on its ancestors.\n",
      "A node's value must be greater than all values in its left subtree and less than all in its right subtree.\n",
      "Consider using inorder traversal which should produce a strictly increasing sequence for a valid BST.\n",
      "Handle edge cases like empty trees and trees with maximum/minimum integer values.\n"
    ],
    "tags": ["tree", "depth-first-search", "binary-search-tree", "binary-tree"]
  },
  {
    "problemId": 23,
    "courseId": "javascript",
    "title": "Same Tree",
    "difficulty": "Easy",
    "description": "Given the roots of two binary trees p and q, check if they are identical. Two trees are identical if they are structurally identical and all corresponding nodes have the same values.\n",
    "examples": [
      {
        "input": "p = [1,2,3], q = [1,2,3]\n",
        "output": "true\n",
        "explanation": "Both trees have the same structure and node values:\n    1         1\n   / \\       / \\\n  2   3     2   3\n"
      },
      {
        "input": "p = [1,2], q = [1,null,2]\n",
        "output": "false\n",
        "explanation": "The trees have different structures:\n    1         1\n   /           \\\n  2             2\n"
      },
      {
        "input": "p = [1,2,1], q = [1,1,2]\n",
        "output": "false\n",
        "explanation": "The trees have the same structure but different node values:\n    1         1\n   / \\       / \\\n  2   1     1   2\n"
      }
    ],
    "constraints": [
      "The number of nodes in both trees is in the range [0, 100].\n",
      "-10^4 <= Node.val <= 10^4\n"
    ],
    "testCases": [
      {
        "input": "p = [1,2,3], q = [1,2,3]\n",
        "expectedOutput": "true\n"
      },
      {
        "input": "p = [1,2], q = [1,null,2]\n",
        "expectedOutput": "false\n"
      },
      {
        "input": "p = [1,2,1], q = [1,1,2]\n",
        "expectedOutput": "false\n"
      },
      {
        "input": "p = [], q = []\n",
        "expectedOutput": "true\n",
        "isHidden": true
      },
      {
        "input": "p = [1,2,null,3], q = [1,2,null,3]\n",
        "expectedOutput": "true\n",
        "isHidden": true
      },
      {
        "input": "p = [1,2,3,4,5], q = [1,2,3,4,5,6]\n",
        "expectedOutput": "false\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Use recursion to compare trees node by node.\n",
      "Base cases: both nodes null (true), one null (false), values different (false).\n",
      "Recursively compare left and right subtrees.\n",
      "Alternatively, use iterative approaches with stacks or queues for traversal.\n",
      "Consider edge cases: empty trees, trees with different heights.\n"
    ],
    "tags": ["tree", "depth-first-search", "breadth-first-search", "binary-tree"]
  },
  {
    "problemId": 24,
    "courseId": "javascript",
    "title": "Binary Tree Level Order Traversal",
    "difficulty": "Medium",
    "description": "Given the root of a binary tree, return the level order traversal of its nodes' values (from left to right, level by level).\n",
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]\n",
        "output": "[[3],[9,20],[15,7]]\n",
        "explanation": "The tree has 3 levels:\nLevel 0: [3]\nLevel 1: [9,20]\nLevel 2: [15,7]\n"
      },
      {
        "input": "root = [1]\n",
        "output": "[[1]]\n",
        "explanation": "The tree has only one node at level 0.\n"
      },
      {
        "input": "root = []\n",
        "output": "[]\n",
        "explanation": "The tree is empty, so the output is empty.\n"
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range [0, 2000].\n",
      "-1000 <= Node.val <= 1000\n"
    ],
    "testCases": [
      {
        "input": "root = [3,9,20,null,null,15,7]\n",
        "expectedOutput": "[[3],[9,20],[15,7]]\n"
      },
      {
        "input": "root = [1]\n",
        "expectedOutput": "[[1]]\n"
      },
      {
        "input": "root = []\n",
        "expectedOutput": "[]\n"
      },
      {
        "input": "root = [1,2,3,4,5,6,7]\n",
        "expectedOutput": "[[1],[2,3],[4,5,6,7]]\n",
        "isHidden": true
      },
      {
        "input": "root = [1,null,2,null,3,null,4]\n",
        "expectedOutput": "[[1],[2],[3],[4]]\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Use breadth-first search (BFS) with a queue to process nodes level by level.\n",
      "For each level, track the number of nodes at that level before processing.\n",
      "Add all nodes of the current level to a sublist, then add their children to the queue.\n",
      "Consider edge cases: empty tree and single-node tree.\n",
      "The queue helps maintain the order of nodes at each level.\n"
    ],
    "tags": ["tree", "breadth-first-search", "binary-tree"]
  },
  {
    "problemId": 25,
    "courseId": "javascript",
    "title": "Maximum Depth of Binary Tree",
    "difficulty": "Easy",
    "description": "Given the root of a binary tree, return its maximum depth.\n\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n",
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]\n",
        "output": "3\n",
        "explanation": "The tree has 3 levels of depth:\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n"
      },
      {
        "input": "root = [1,null,2]\n",
        "output": "2\n",
        "explanation": "The tree has 2 levels of depth:\n    1\n     \\\n      2\n"
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range [0, 10^4].\n",
      "-100 <= Node.val <= 100\n"
    ],
    "testCases": [
      {
        "input": "root = [3,9,20,null,null,15,7]\n",
        "expectedOutput": "3\n"
      },
      {
        "input": "root = [1,null,2]\n",
        "expectedOutput": "2\n"
      },
      {
        "input": "root = []\n",
        "expectedOutput": "0\n",
        "isHidden": true
      },
      {
        "input": "root = [0]\n",
        "expectedOutput": "1\n",
        "isHidden": true
      },
      {
        "input": "root = [1,2,3,4,5,6,7,8]\n",
        "expectedOutput": "4\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Use recursion to calculate the depth of each subtree.\n",
      "The maximum depth is 1 (for current node) plus the maximum of left and right subtree depths.\n",
      "Base case: if node is null, return depth 0.\n",
      "Alternatively, use BFS with a queue to count levels.\n",
      "For BFS, count how many level traversals you complete.\n"
    ],
    "tags": ["tree", "depth-first-search", "breadth-first-search", "binary-tree"]
  },
  {
    "problemId": 26,
    "courseId": "javascript",
    "title": "Construct Binary Tree from Preorder and Inorder Traversal",
    "difficulty": "Medium",
    "description": "Given two integer arrays preorder and inorder representing the preorder and inorder traversals of a binary tree, construct and return the binary tree.\n\nNote: All values in the traversals are unique.\n",
    "examples": [
      {
        "input": "preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\n",
        "output": "[3,9,20,null,null,15,7]\n",
        "explanation": "The constructed tree:\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n"
      },
      {
        "input": "preorder = [-1], inorder = [-1]\n",
        "output": "[-1]\n",
        "explanation": "The tree contains only one node with value -1.\n"
      }
    ],
    "constraints": [
      "1 <= preorder.length <= 3000\n",
      "inorder.length == preorder.length\n",
      "-3000 <= preorder[i], inorder[i] <= 3000\n",
      "All values in preorder and inorder are unique\n",
      "Each value in inorder also appears in preorder\n",
      "preorder is guaranteed to be a valid preorder traversal\n",
      "inorder is guaranteed to be a valid inorder traversal\n"
    ],
    "testCases": [
      {
        "input": "preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\n",
        "expectedOutput": "[3,9,20,null,null,15,7]\n"
      },
      {
        "input": "preorder = [-1], inorder = [-1]\n",
        "expectedOutput": "[-1]\n"
      },
      {
        "input": "preorder = [1,2,3], inorder = [3,2,1]\n",
        "expectedOutput": "[1,2,null,3]\n",
        "isHidden": true
      },
      {
        "input": "preorder = [1,2,4,5,3,6,7], inorder = [4,2,5,1,6,3,7]\n",
        "expectedOutput": "[1,2,3,4,5,6,7]\n",
        "isHidden": true
      }
    ],
    "hints": [
      "The first element in preorder is always the root of the tree or subtree.",
      "In inorder traversal, all elements before the root element belong to the left subtree, and all after belong to the right subtree.",
      "Use a hashmap to store the indices of inorder elements for quick lookup.",
      "Recursively build the left and right subtrees using the divided inorder and preorder arrays.",
      "The key is to correctly identify the boundaries of left and right subtrees in both traversals."
    ],
    "tags": ["array", "hash-table", "divide-and-conquer", "tree", "binary-tree"]
  },
  {
    "problemId": 27,
    "courseId": "javascript",
    "title": "Best Time to Buy and Sell Stock",
    "difficulty": "Easy",
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\n",
    "examples": [
      {
        "input": "prices = [7,1,5,3,6,4]\n",
        "output": "5\n",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying must occur before selling.\n"
      },
      {
        "input": "prices = [7,6,4,3,1]\n",
        "output": "0\n",
        "explanation": "No transactions are done as prices keep decreasing, so max profit = 0.\n"
      }
    ],
    "constraints": [
      "1 <= prices.length <= 10^5\n",
      "0 <= prices[i] <= 10^4\n"
    ],
    "testCases": [
      {
        "input": "prices = [7,1,5,3,6,4]\n",
        "expectedOutput": "5\n"
      },
      {
        "input": "prices = [7,6,4,3,1]\n",
        "expectedOutput": "0\n"
      },
      {
        "input": "prices = [1,2,3,4,5]\n",
        "expectedOutput": "4\n",
        "isHidden": true
      },
      {
        "input": "prices = [2,4,1]\n",
        "expectedOutput": "2\n",
        "isHidden": true
      },
      {
        "input": "prices = [3,2,6,5,0,3]\n",
        "expectedOutput": "4\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Track the minimum price encountered so far as you iterate through the array.",
      "For each price, calculate the potential profit if you sold at that price (current price - minimum price so far).",
      "Keep updating the maximum profit found during the iteration.",
      "The solution requires only one pass through the array with O(1) space complexity.",
      "Focus on finding the largest peak following the smallest valley."
    ],
    "tags": ["array", "dynamic-programming"]
  },
  {
    "problemId": 28,
    "courseId": "javascript",
    "title": "Search in Rotated Sorted Array",
    "difficulty": "Medium",
    "description": "There is an integer array nums sorted in ascending order (with distinct values).\n\nPrior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed).\n\nGiven the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\n\nYou must write an algorithm with O(log n) runtime complexity.\n",
    "examples": [
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 0\n",
        "output": "4\n",
        "explanation": "The target 0 is found at index 4 in the rotated array.\n"
      },
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 3\n",
        "output": "-1\n",
        "explanation": "The target 3 is not found in the rotated array.\n"
      },
      {
        "input": "nums = [1], target = 0\n",
        "output": "-1\n",
        "explanation": "The target 0 is not found in the array containing only [1].\n"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 5000\n",
      "-10^4 <= nums[i] <= 10^4\n",
      "All values of nums are unique.\n",
      "nums is an ascending array that is possibly rotated.\n",
      "-10^4 <= target <= 10^4\n"
    ],
    "testCases": [
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 0\n",
        "expectedOutput": "4\n"
      },
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 3\n",
        "expectedOutput": "-1\n"
      },
      {
        "input": "nums = [1], target = 0\n",
        "expectedOutput": "-1\n"
      },
      {
        "input": "nums = [6,7,8,1,2,3,4,5], target = 8\n",
        "expectedOutput": "2\n",
        "isHidden": true
      },
      {
        "input": "nums = [4,5,6,7,8,1,2,3], target = 1\n",
        "expectedOutput": "5\n",
        "isHidden": true
      }
    ],
    "hints": [
      "The array is rotated but still maintains sorted order in two parts.\n",
      "Use binary search to determine which half is properly sorted.\n",
      "Check if the target lies within the sorted half to decide which half to search next.\n",
      "Remember to handle the edge cases where the array is not rotated or has only one element.\n"
    ]
  },
  
  {
    "problemId": 29,
    "courseId": "javascript",
    "title": "Merge Two Sorted Lists",
    "difficulty": "Easy",
    "description": "You are given the heads of two sorted linked lists list1 and list2.\n\nMerge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.\n\nReturn the head of the merged linked list.\n",
    "examples": [
      {
        "input": "list1 = [1,2,4], list2 = [1,3,4]\n",
        "output": "[1,1,2,3,4,4]\n",
        "explanation": "The lists are merged in sorted order by splicing the nodes together.\n"
      },
      {
        "input": "list1 = [], list2 = []\n",
        "output": "[]\n",
        "explanation": "Both lists are empty so the result is also empty.\n"
      },
      {
        "input": "list1 = [], list2 = [0]\n",
        "output": "[0]\n",
        "explanation": "An empty list merged with [0] results in [0].\n"
      }
    ],
    "constraints": [
      "The number of nodes in both lists is in the range [0, 50].\n",
      "-100 <= Node.val <= 100\n",
      "Both list1 and list2 are sorted in non-decreasing order.\n"
    ],
    "testCases": [
      {
        "input": "list1 = [1,2,4], list2 = [1,3,4]\n",
        "expectedOutput": "[1,1,2,3,4,4]\n"
      },
      {
        "input": "list1 = [], list2 = []\n",
        "expectedOutput": "[]\n"
      },
      {
        "input": "list1 = [], list2 = [0]\n",
        "expectedOutput": "[0]\n"
      },
      {
        "input": "list1 = [1,3,5], list2 = [2,4,6]\n",
        "expectedOutput": "[1,2,3,4,5,6]\n",
        "isHidden": true
      },
      {
        "input": "list1 = [5], list2 = [1,2,4]\n",
        "expectedOutput": "[1,2,4,5]\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Use a dummy node to simplify the merging process.\n",
      "Compare the nodes of both lists and attach the smaller one to the merged list.\n",
      "Don't forget to attach the remaining nodes when one list is exhausted.\n"
    ]
  },
  {
    "problemId": 30,
    "courseId": "javascript",
    "title": "Remove Nth Node From End of List",
    "difficulty": "Medium",
    "description": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n",
    "examples": [
      {
        "input": "head = [1,2,3,4,5], n = 2\n",
        "output": "[1,2,3,5]\n",
        "explanation": "The 2nd node from the end is node with value 4, which is removed.\n"
      },
      {
        "input": "head = [1], n = 1\n",
        "output": "[]\n",
        "explanation": "The only node is removed, resulting in an empty list.\n"
      },
      {
        "input": "head = [1,2], n = 1\n",
        "output": "[1]\n",
        "explanation": "The last node (value 2) is removed.\n"
      }
    ],
    "constraints": [
      "The number of nodes in the list is sz.\n",
      "1 <= sz <= 30\n",
      "0 <= Node.val <= 100\n",
      "1 <= n <= sz\n"
    ],
    "testCases": [
      {
        "input": "head = [1,2,3,4,5], n = 2\n",
        "expectedOutput": "[1,2,3,5]\n"
      },
      {
        "input": "head = [1], n = 1\n",
        "expectedOutput": "[]\n"
      },
      {
        "input": "head = [1,2], n = 1\n",
        "expectedOutput": "[1]\n"
      },
      {
        "input": "head = [1,2,3,4,5,6,7,8,9,10], n = 7\n",
        "expectedOutput": "[1,2,4,5,6,7,8,9,10]\n",
        "isHidden": true
      },
      {
        "input": "head = [1,2,3], n = 3\n",
        "expectedOutput": "[2,3]\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Maintain two pointers and update one with a delay of n steps.\n",
      "The key is to find the nth node from the end in one pass.\n",
      "Consider using a dummy node to handle edge cases where you need to remove the head.\n"
    ],
    "solution": "function removeNthFromEnd(head, n) {\n  let dummy = new ListNode(0);\n  dummy.next = head;\n  let first = dummy;\n  let second = dummy;\n  \n  for (let i = 0; i <= n; i++) {\n    first = first.next;\n  }\n  \n  while (first !== null) {\n    first = first.next;\n    second = second.next;\n  }\n  \n  second.next = second.next.next;\n  return dummy.next;\n}",
    "tags": ["linked-list", "two-pointers"]
  }
] 